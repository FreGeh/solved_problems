# Dynamic Programming

## Dice Combinations
- **Intuition**: Check for each possible dice roll $1\leq i \leq 6$ what the amount of combinations was before $dp[i-j]$.
- **Runtime**: $\Theta(n\cdot 6)$
```cpp
int main() {
    ios::sync_with_stdio(false); cin.tie(nullptr);

    ll n; cin>>n;

    vector<ll> dp(n+1);
    const int MOD = 1000000007;
    dp[0]=1;

    for (int i=1;i<n+1;i++) {
        ll sum = 0;
        for (int j=1;j<=6;j++) {
            if (i-j>=0) {
                sum+=(dp[i-j] % MOD);
            }
        }
        dp[i]=sum % MOD;
    }
    cout << dp[n];

    return 0;
}
```

## Minimizing Coins
- **Intuition**: For each value $1 \leq i \leq x$ we calculate the min amount of coins to get $i$. We do this by going through all our coins $c \in C$ and checking how many coins we needed previously for $i-c$. We take the value of best possible min combinationand just add one, so $1+dp[i-c_i]$, since we just gotta add that one single coin $c_i$ to reach $i$.
- **Runtime**: $\Theta(n\cdot x)$

**Top-Down:**
```cpp
int main() {
    ios::sync_with_stdio(false); cin.tie(nullptr);

    int n,x;
    cin>>n>>x;
    const int INF=x+1;
    vector<int> coins(n);
    for (auto &c : coins) {
        cin>>c;
    }

    vector<int> dp(x+1, INF);
    dp[0]=0;
    for (int i=1;i<=x;i++) {
        for (int c : coins) {
            if (c <= i) {
                dp[i] = min(dp[i], dp[i - c] + 1);
            }
        }
    }
    cout << (dp[x]>x ? -1 : dp[x]) <<"\n";
    return 0;
}
```

**Bottom-Up**:
```cpp

```

## Coin Combinations I
- **Intuition**: We calculate amount of combinations to get $i$, by checking the amount of combinations for each $c \in C: dp[i-c]$. 
- **Runtime**: $\Theta(n\cdot x)$
```cpp
int main() {
    ios::sync_with_stdio(false); cin.tie(nullptr);

    int n,x; cin>>n>>x;
    vector<int> coins(n);
    for (auto &c : coins) {
        cin>>c;
    }
    
    const int MOD = 1000000007;
    vector<ll> dp(x+1, 0);
    dp[0]=1;

    for (int i=1;i<x+1;i++) {
        ll sum = 0;
        for (auto c : coins) {
            if (i-c>=0) {
                sum+=(dp[i-c] % MOD);
            }
        }
        dp[i]=sum % MOD;
    }
    cout << dp[x];

    return 0;
}
```

