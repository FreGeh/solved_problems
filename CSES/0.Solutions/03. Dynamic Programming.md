# Dynamic Programming

## Dice Combinations
- **Intuition**: Check for each possible dice roll $1\leq i \leq 6$ what the amount of combinations was before $dp[i-j]$.
- **Runtime**: $\Theta(n\cdot 6)$
```cpp
int main() {
    ios::sync_with_stdio(false); cin.tie(nullptr);

    ll n; cin>>n;

    vector<ll> dp(n+1);
    const int MOD = 1000000007;
    dp[0]=1;

    for (int i=1;i<n+1;i++) {
        ll sum = 0;
        for (int j=1;j<=6;j++) {
            if (i-j>=0) {
                sum+=(dp[i-j] % MOD);
            }
        }
        dp[i]=sum % MOD;
    }
    cout << dp[n];

    return 0;
}
```

## Minimizing Coins
- **Intuition**: For each value $1 \leq i \leq x$ we calculate the min amount of coins to get $i$. We do this by going through all our coins $c \in C$ and checking how many coins we needed previously for $i-c$. We take the value of best possible min combinationand just add one, so $1+dp[i-c_i]$, since we just gotta add that one single coin $c_i$ to reach $i$.
- **Runtime**: $\Theta(n\cdot x)$

**Top-Down:**
```cpp
int main() {
    ios::sync_with_stdio(false); cin.tie(nullptr);

    int n,x;
    cin>>n>>x;
    const int INF=x+1;
    vector<int> coins(n);
    for (auto &c : coins) {
        cin>>c;
    }

    vector<int> dp(x+1, INF);
    dp[0]=0;
    for (int i=1;i<=x;i++) {
        for (int c : coins) {
            if (c <= i) {
                dp[i] = min(dp[i], dp[i - c] + 1);
            }
        }
    }
    cout << (dp[x]>x ? -1 : dp[x]) <<"\n";
    return 0;
}
```

**Bottom-Up**:
```cpp

```

## Coin Combinations I
- **Intuition**: We count amount of every possible sorted sequences (**permutations**) of coins. Every sequence summing to $i$ has a unique last coin $c \in C$, so the prefix can be any ordered sequence summing to $i-c$. 
- **Runtime**: $\Theta(n\cdot x)$
```cpp
int main() {
    ios::sync_with_stdio(false); cin.tie(nullptr);

    int n,x; cin>>n>>x;
    vector<int> coins(n);
    for (auto &c : coins) {
        cin>>c;
    }
    
    const int MOD = 1000000007;
    vector<ll> dp(x+1, 0);
    dp[0]=1;

    for (int i=1;i<x+1;i++) {
        ll sum = 0;
        for (auto c : coins) {
            if (i-c>=0) {
                sum+=(dp[i-c] % MOD);
            }
        }
        dp[i]=sum % MOD;
    }
    cout << dp[x];

    return 0;
}
```

## Coin Combinations II
- **Intuition**: We count amount of possible unordered combinations (**multisets**) of coins. We define $dp(k,i)$ as ways to make sum $i$ only using first $k$ coins $\{c_1,\dots,c_k\}$. Then the recurrence is $dp(k,i)=dp(k-1,i)+dp(k,i-c_k)$.
- **Runtime**: $\Theta(n\cdot x)$
```cpp
int main() {
    ios::sync_with_stdio(false); cin.tie(nullptr);

    int n,x; cin>>n>>x;
    vector<int> coins(n);
    for (auto &c : coins) {
        cin>>c;
    }

    const int MOD =1000000007;
    vector<ll> dp(x+1, 0);
    dp[0]=1;

    for (int c : coins) {
        for (int i = c; i < x+1; ++i) {
            dp[i] = (dp[i] + dp[i-c]) % MOD;
        }
    }
    cout << dp[x];

    return 0;
}
```

## Removing Digits
- **Intuition**: Imagine all numbers $0\leq i \leq n$ as nodes in a graph (DAG), for each digit $d\in \text{digits}(i)$ we add the edge $e=(i, i-d)$. Therefore $dp[i]$ is the shortes path from $i$ to $0$. We always pick the digit $d$ that leads to smallest $i-d$.
- **Runtime**: $O(n)$

```cpp
int main() {
    ios::sync_with_stdio(false); cin.tie(nullptr);

    int n;cin>>n;
    
    const int INF = INT_MAX;
    vector<int> dp(n+1, INF);
    dp[0]=0;

    for (int i=1; i<n+1; i++) {
        int x = i;
        while (x) { //!=0
            int d = x % 10;
            if (d) { //!=0
                dp[i] = min(dp[i], dp[i - d] + 1);
            }
            x /= 10;
        }
    }
    cout<<dp[n];
    return 0;
}
```

